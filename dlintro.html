<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Nikolaos Sarafianos blog</title>
    <meta name="viewport" content="width=device-width">
<!--    <meta name="description" content="Musings of a Computer Scientist.">-->
    <link rel="canonical" href="https://nsarafianos.github.io/">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="css/main.css">

    <!-- Google Analytics -->

  </head>


  <body>

<header class="site-header">

<div class="wrap">

 <div style="float:left; margin-top:10px; margin-right:10px;">
      <img src="assets/rssicon.svg" width="30">
 </div> 
    <a class="site-title" href="/">Nikos Sarafianos blog</a>

<nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
        </svg>
      </a>
      <div class="trigger">
        
          <a class="page-link" href="about.html">Me, Myself &amp; I</a>
        
        
      </div>
</nav>
    
</div>


</header>

<div class="page-content">
<div class="wrap">
<div class="post">
<header class="post-header">
    <h1>Deep Renaissance: How I approached Deep Learning</h1>
    <p class="meta">July 23, 2016</p>
</header>

Two years in my Ph.D. I decided to start working on Deep Learning with ConvNets. This post summarizes the lessons learned after one month of digging into ConvNets. </br></br>
    
<font size="4">Contents
<ul>
    <li><a href="#setup">Setting it up</a></li>
    <li><a href="#howtostart">How to start?</a></li>
    <li><a href="#structureandlayers">Structure and Layers</a></li>
    <li><a href="#activationfunctions">Activation Functions</a></li>
    <li><a href="#overfitting">Overfitting</a></li>
    <li><a href="#augmentation">Data augmentation</a></li>
    <li><a href="#finetuning">Fine-tuning</a></li>
    <li><a href="#dropout">Dropout</a></li>
    <li><a href="#definingconvnets">Defining a ConvNet in Lasagne</a></li>
    <li><a href="#conclusion">Conclusions</a></li>
</ul>
</font>        
<a name="setup"></a>
<h3>Setting it up</h3>
    The framework I've been using is <a href="http://deeplearning.net/software/theano/">Theano</a> along with <a href="https://github.com/Lasagne/Lasagne">Lasagne</a> which is a lightweight library to build and train neural networks in Theano. It has sufficient and well-written documentation (<a href="http://lasagne.readthedocs.io/en/latest/">here</a> and <a href="https://media.readthedocs.org/pdf/lasagne/latest/lasagne.pdf">here</a>), has many capabilities (e.g.,  layers, initializations) and at the same time it's low-level enough so as to give you the option to code almost everything.</br>
    
The first thing you need to do is get a CUDA-capable GPU to run your programs. It might seem obvious but it's almost impossible to conduct experiments with many epochs, test different network structures, cross-validate, and report results from an ensemble of models on a CPU. It can be on your desktop, on Amazon Web Services, or in a cluster. </br>

Then you need to make sure that you have set up everything. This includes the <i>.theanorc</i> file, the creation and activation of a virtualenv as explained in a <a href="http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial/#prerequisites">great blog</a> by Daniel Nouri (the instructions are <a href="http://deeplearning.net/software/theano/tutorial/using_gpu.html">here</a> and more help can be found <a href="https://virtualenv.pypa.io/en/stable/reference/#virtualenv-command">here</a> and <a href="https://www.dabapps.com/blog/introduction-to-pip-and-virtualenv-python/">here</a>). Besides Theano and Lasagne, other packages I'm using regularly include numpy, scipy, pandas, scikit-learn, PIL, matplotlib, OpenCV and <a href="https://github.com/dnouri/nolearn">nolearn</a>. Then test that everything works fine by running the <a href="http://yann.lecun.com/exdb/mnist">MNIST</a> example as explained in Nouri's blog above.  

<a name="howtostart"></a>      
<h3>How to start?</h3>

Since there are tons of papers coming out every year on deep learning, videos, lectures, online classes, and tutorials the question that arises is "from where do you start?" Before anything else, there are three wonderful sources I would suggest:

<ul>
    <li> The <a href="http://neuralnetworksanddeeplearning.com/">electronic book</a> of Michael Nielsen on Neural networks and deep learning for the reason that it starts from basic Neural Networks, provides detailed explanations with figures, examples and code and builds gradually on top of that in order to introduce Deep Learning in the final chapter.</li>
    <li> The Stanford <a href="http://cs231n.github.io/">Convolutional Neural Networks for Visual Recognition</a> class by Prof. Fei-Fei Li, Andrej Karpathy and Justin Johnson. The notes are well-written, it's very up to date with the current state of the art and the videos of the lectures which were initially <a href="https://twitter.com/karpathy/status/727618058471112704">taken down</a> can be found <a href="https://www.youtube.com/playlist?list=PLlJy-eBtNFt6EuMxFYRiNRS07MCWN5UIA">here</a>.</li>
    <li>  Daniel Nouri's <a href="http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial">tutorial</a> on employing ConvNets to detect facial keypoints using regression as part of a Kaggle challenge.</li>
</ul>
I would then suggest to follow the social media profiles of researchers that you look up to or you like their work. For example by following Yann LeCun on Facebook I came across this <a href="https://www.facebook.com/yann.lecun/posts/10152348155137143">very interesting discussion</a> on ConvNets, his <a href="http://www.college-de-france.fr/site/en-yann-lecun/course-2015-2016.htm">videos</a> and <a href="https://drive.google.com/folderview?id=0BxKBnD5y2M8NclFWSXNxa0JlZTg&usp=drive_web">slides </a> from classes and seminars from the Deep Learning course he offered in Coll√®ge de France. Andrew Ng recently posted that he will deliver online for free his <a href="http://www.mlyearning.org/".>new Machine Learning book</a> to some early subscribers. Following the website of companies that conduct research on AI or Machine Learning such as <a href="https://openai.com/blog/generative-models/">OpenAI</a>, <a href="https://deepmind.com/blog">Google DeepMind</a>, <a href ="https://research.facebook.com/blog/">Facebook AI Research</a> etc. can also be very beneficial. Since deep learning is a field that expands at a great pace, the only way to keep up is read, and then read some more.  

      
<a name="structureandlayers"></a>       
<h3>Structure and Layers</h3>    

For image-related tasks, ConvNets take a dataset of images along with their respective labels as an input and train a model that given a new image it can predict its label. 

<figure>
    <img src="assets/Typical_cnn.png" width="800">
    <figcaption>Figure 1: A ConvNet example with a structure of Input - (Conv - Pool)&#215;2 - FC - FC (Output).</figcaption>
</figure></br>
    
A typical ConvNet looks like Figure 1 and comprises: </br></br>

<ul>
    <li> An <b>input layer</b> that feeds the images to the network and its only parameter is the "shape" which for an RGB image of size N&#215;N is defined as <i>shape=(None, 3, N,N)</i></li></br>
    <li> <b>Convolutional layers</b> are where all the magic happens. The neurons are arranged in three dimensions (width, height, depth) and the key characteristics are the <b>local receptive fields</b> and the <b>parameter sharing</b>. </li></br>
    <ul>
        <li><b>Local receptive fields</b>: Since images are high dimensional, it's computationally expensive and impractical to make all the connections between two subsequent layers of neurons. Instead, each neuron of the convolutional layer is connected only to a specific region of the image (if we're talking about the first convolutional layer), and this region is the local receptive field. Its size (i.e., filter size) is a hyperparameter that usually has a value of 3 or 5.</br> During the forward pass, the local receptive field is slid across the input (this is where convolutions take place) and each local receptive field on the input volume corresponds to a different hidden neuron. The step with which the local receptive field is slid across the image is called stride (also a hyperparameter). Note that, the local receptive field slides through the width and the height but extends through the full depth of the input volume.</li></br>
        <li><b>Parameter sharing</b>: For an RGB image (i.e., 3 color channels and thus, depth equal to 3) the first convolutional layer with a filter size equal to 5 we will have 5&#215;5&#215;3 = 75 weights plus the bias. These weights and the bias will be the same <b>for each depth dimension</b> and this is called parameter sharing and reduces a lot the number of parameters that have to be learned. It has to be mentioned that the mapping from one layer to the other (for example from the input to the first convolutional or between two convolutional layers) can take place many times and each one of these times is a <b>feature map</b>. Each feature map detects a different kind of feature.</br> For example, if we assume that the first convolutional layer learns basic generic features (which can be edges, corners, etc.) we can have 16 feature maps from the input image to the first layer. Thus, the parameters between feature maps are different, but in the same feature map, they are the same. As mentioned in the <a href=" http://cs231n.github.io/convolutional-networks/#conv">Stanford class notes</a>, this property of parameter sharing enables the computation of the convolutional layer during the forward pass to be computed as a convolution of the neuron's weights with the input volume. </li>
    </ul></br>
    <li><b>Pooling layers</b> are layers that are usually placed after the convolutional layers and by reducing the spatial size of the representation (i.e., the width and the height) they reduce the number of parameters that have to be learned. A pooling layer has two parameters, namely the filter size and the stride. For every depth dimension, a pooling layer with a filter size of 2&#215;2 and a stride of 2, discards 75% of the activations as it outputs one number for every four that takes as an input and thus for an N&#215;N&#215;D input it outputs (N/2)&#215;(N/2)&#215;D (and that's why the image size is convenient if it can be divided by 2 many times without any remainder). Pooling layers can output the maximum (max-pooling), the mean, the L2 norm etc.</li></br>
    <li><b>Fully connected layers</b> are layers like the ones that are used in regular neural networks and have full connections with the previous layers. They are usually placed at the end of the ConvNet and the number of hidden units is another hyperparameter. </li></br>
    <li><b>The output layer</b> is also a fully connected layer which during training computes an output prediction and backpropagates the error from the loss function to the neural network. Its number of units depends on the number of the classes of the problem (e.g., 2 for a binary problem, 10 for MNIST, 1000 for ImageNet competitions) and for classification tasks it's usually followed by a <a href="https://en.wikipedia.org/wiki/Softmax_function">softmax</a> non-linearity function.</li>
</ul>

<a name="activationfunctions"></a>  
<h3>Activation Functions</h3> 

After the dot product of the input and weights is computed and the bias is added, the result is passed through a non-linearity. Regular neural networks are making use of the sigmoid or tanh activation functions. In ConvNets the most frequently used non-linearity is the Rectified Linear Unit (ReLU) function which is as simple as the max(0,x) where x is the input to the neuron. </br></br>Variants of the ReLU have been proposed recently <a href="#references">[1]</a>  such as the Parametric Rectified Linear Unit (PReLU also called leaky-ReLU) which allows a small non-zero gradient (controlled by a parameter &alpha;) when the unit is not active (instead of zero) as depicted in Figure 2. The activation function (for example the ReLU) applies elementwise the function to every neuron and thus, leaves the volume size unchanged. 

<figure>
    <img src="assets/ReLu.png" width="800">
    <figcaption>Figure 2: ReLU and leaky-ReLU</figcaption>
</figure>

<a name="overfitting"></a>
<h3>Overfitting</h3>
Overfitting in ConvNets is a crucial piece of information and at the same time a huge struggle to control it. Something that I learned the hard way is that overfitting at the beginning is required, because it means that the selected network structure can at least represent adequately the training data. If there's no overfitting initially at the training set then most likely the network is not sufficient (deep enough, complex enough etc.) After you have overfitted the training set there are a couple of techniques to control this phenomenon. 

<a name="augmentation"></a>
<h3>Data augmentation</h3>    
When your dataset does not have a lot of data or if you're overfitting your training set then a common technique is dataset augmentation which artificially increases the number of training samples. In each mini-batch iteration, a subset is randomly selected each time and augmentation is usually performed only in this subset. The power of data augmentation is that it's performed <b>while iterating over the batch samples</b> and thus, in theory, it allows us to produce an infinite number of training samples. If it was performed beforehand then the training set would be of fixed size and most likely it would take a lot of memory space. </br></br>
      
Data augmentation can be implemented by: 
<ul>
    <li> transformations such as translations, rotations, scaling, cropping</li>
    <li> flipping the images (horizontally or even vertically <a href="http://benanne.github.io/2014/04/05/galaxy-zoo.html">if you're dealing with galaxies</a>)</li>
    <li> adding noise</li>
</ul></br>  
During data augmentation you need to be careful with the size of the output image since since depending on the transformation and the selected options the output size may vary.  Krizhevsky et al. <a href="#references">[2]</a> proposed to augment the training set by performing PCA on the set of RGB pixel values throughout the training set:  
<ul>
    <li> Compute the 3&#215;3 covariance matrix Xc <b>on the whole training set</b>.</li>
    <li> Compute the eigenvalues (l) and eigenvectors (V) of Xc</li>
    <li> <b>For each image</b>, compute a random variable &alpha; sampled from a Gaussian distribution with zero mean and 0.1 standard deviation &alpha;~N(0,0.1)</li>
    <li> Compute the noise to be added as the dot product between V and [&alpha;&#215;l]. </li>
    <li> Add the computed noise to each RGB image pixel.</li>
</ul> </br>

As the authors mention, each &alpha; is drawn only once for all the pixels of a particular training image until that image is used for training again, at which point it is re-drawn. <a href="https://github.com/lucasb-eyer/lbtoolbox/commit/315e3a6">This</a> code provides an object-oriented implementation which can be re-written as follows: </br></br>

<pre>def PCA_augmentation(batch, l, V):</br>  for i in xrange(batch.shape[0]):</br>       alpha = np.random.randn(3) * 0.1</br>       noise = np.dot(V, alpha * l)</br>       batch[i, :, :, :] = batch[i, :, :, :] + noise[:, np.newaxis, np.newaxis]</br>  return batch</br></pre>  </br> 
Where the eigenvalues and eigenvectors are computed before starting the training as follows:</br></br>
<pre>Xtr = np.rollaxis(X, 1) # X is the training set</br>Xtr = Xtr.reshape((Xtr.shape[0], -1))</br>l, V = np.linalg.eig(np.cov(Xtr))</br></pre> 

<h3>Batch Normalization</h3>     
    Introduced by Ioffe and Szegedy in 2015 <a href="#references">[3]</a>, batch normalization is a technique that in each layer performs normalization <b>across the batch</b> and makes the model more generalizable by reducing the covariate shift and whitening the activations. It also solves the problem of bad weight initialization and increases the learning speed. It is inserted immediately after fully connected layers (or convolutional layers), and <b>before non-linearities</b> as depicted in Figure 3. An interesting Quora discussion on batch normalization can be found <a href="https://www.quora.com/Why-does-batch-normalization-help">here</a> and recently, Arpit et al. <a href="#references">[4]</a> proposed an alternative to BN for removing the internal covariate shift problem by Normalization Propagation (NormProp). 

<figure>
    <img src="assets/BN.png" width="500">
    <figcaption>Figure 3: Batch Normalization and where it takes place</figcaption>
</figure>

<a name="finetuning"></a>
<h3>Fine-tuning</h3>
Training a ConvNet from scratch is definitely an exciting and challenging task that is worth trying because it gives you the opportunity to understand in greater depth how things work in each layer and in the ConvNet as a whole. However, if you don't have a lot of data (which is usually the case since labeled data like ImageNet are rare) if you train a ConvNet from scratch overfitting will be unavoidable regardless of what regularization techniques you're using or to what extent you're augmenting the training data. Similar to Caffe, Lasagne-based pre-trained models can be found in <a href="https://github.com/Lasagne/Recipes">recipes</a> under the modelzoo folder. The way I see it, using a pre-trained model is equivalent to a good weight initialization across all layers of the network. I will give an example based on VGG-16 <a href="#references">[5]</a> along with a few lessons learned from fine-tuning it. </br></br>

VGG-16 which was designed for ILSVRC-2014 comprises 5 groups of layers, where each group consists of 2 or 3 convolutional layers with a ReLU activation function followed by a max-polling layer. Two dense layers are then stacked followed by a non-linearity layer that computes the softmax. Since VGG was designed to tackle a problem with 1000 possible output classes its structure is very deep and thus, the parameters that need to be learned are more than 100 million. For a problem with a few output classes such a deep network (even if it's used only for fine-tuning) can be problematic due to the fact that deepness affects significantly the training time.

By playing with VGG-16 (it can be extended to other models depending on the structure of course) I learned the following:
<ul>
    <li>If you're planning to use it "as is" which means along with the FC layers then the size of the input image cannot be different since from the last convolutional layer to the first fully connected, its size at that time (after pooling has been applied across the network) plays some role. As Andrej Karpathy mentions you can tackle this by converting fully connected to convolutional layers or you can just drop the fully connected layers and replace them with a global pooling layer (just an example) as He et al. suggest in <a href="#references">[1]</a>. </li>
    <li>Since ConvNets learn hierarchical representations starting from low-level features (such as edges) in early layers to high-level output-dependant features (such as dog breeds) in latter, depending on the task you might want to drop some latter layers and replace them with other layers the weights of which will have to be learned. In such a scenario, the layers that are kept require a smaller learning rate than the new ones that are randomly initialized and their weights need to be learned from scratch. An approach that fine-tunes VGG while adding on top new layers and uses 2 different learning rates is proposed by Kruthiventi et al. <a href="#references">[6]</a>. Different learning rates across the network can easily be used in lasagne by passing the update parameters in each layers separately as suggested in <a href="https://groups.google.com/forum/#!topic/lasagne-users/2z-6RrgiHkE">this</a> topic.</li>
</ul>

<a name="dropout"></a>
<h3>Dropout</h3>
Dropout is a powerful regularization technique introduced by Srivastava et al. <a href="#references">[7]</a> to address the problem of overfitting. Instead of adding regularization terms to the cost function (as L1 and L2 regularization techniques do), dropout modifies <b>during training</b> the network itself. What dropout does during training, is randomly dropping for each epoch, a percentage of units (along with the corresponding connections) from some selected layers of the ConvNet and passing the training set through what's left. </br></br>

For example, if dropout is applied with a probability of 50% after a fully-connected layer with 1024 units, then in each epoch 512 units of the layer are randomly dropped at training time. Thus, the neurons in the respective layers try to learn representations without relying too much on other neurons on the same layer (co-adaptation) and try to learn more robust representations. At test time, all the neurons are going to be active which means that (if the probability of dropout was N%) 100/N as many neurons will be active compared to the training stage. To alleviate this, weights that come out of the respective layer are divided by 100/N. </br></br>

To understand dropout better, I would suggest reading the <a href="http://www.jmlr.org/papers/volume15/srivastava14a.old/source/srivastava14a.pdf">original paper</a> along with the aforementioned  <a href="http://neuralnetworksanddeeplearning.com/chap3.html#other_techniques_for_regularization">electronic book chaptrer</a> of Michael Nielsen. Additionally, in the Stanford ConvNet class, the <a href="http://cs231n.github.io/neural-networks-2/#reg">inverted dropout</a> technique is discussed, which performs the scaling described above, during training, leaving the forward pass at test time untouched. Goodfellow et al. <a href="#references">[8]</a> proposed maxout, a natural companion to dropout. The maxout model is simply a feed-forward achitecture, such as a multilayer perceptron or deep convolutional neural network, that uses a new type of activation function: the maxout unit. It facilitates the optimization by dropout and improves the accuracy of dropout‚Äôs fast approximate model averaging technique.


<a name="definingconvnets"></a>
<h3>Defining a ConvNet in Lasagne</h3>
<u>Approach 1</u></br>
When I started playing with Deep Learning, I followed the approach of Daniel Nouri's <a href="http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial/#second-model-convolutions">tutorial</a> to define a network in Lasagne using nolearn. For example:</br></br>
<pre>net = NeuralNet(</br>  layers=[</br>       ('input', layers.InputLayer),</br>       ('conv1', layers.Conv2DLayer),</br>       ('output', layers.DenseLayer),</br>  ],</br>  input_shape=(None, 1, 96, 96)</br>  conv1_num_filters=32, conv1_filter_size=(3, 3)</br>  output_num_units= 30, max_epochs=1000,</br>)</pre></br>

Defining a network like that with the help of nolearn is nice because: 
<ul>
    <li>It's clearly written, easy to understand and adding parameters that correspond to each layer (according to the way layers are <a href="http://lasagne.readthedocs.io/en/latest/modules/layers.html">defined</a>) is simple.</li>
    <li>It enables you to use scikit-learn's pipeline and cross-validation features (for example the <a href="http://scikit-learn.org/stable/modules/generated/sklearn.grid_search.RandomizedSearchCV.html">RandomizedSearchCV</a> function.</li>
</ul></br>

<u>Approach 2</u></br>
However, at some point I decided that I wanted to use batch normalization in some layers which comes in the form of the <a href="http://lasagne.readthedocs.io/en/latest/modules/layers/normalization.html#lasagne.layers.batch_norm">batch_norm</a> function in lasagne and requires not a layer class type (Conv2DLayer) but an instance of it. Thus, I changed the previous network definition to this one: </br></br>
<pre><i># Defining the layers first</i></br>l = layers.InputLayer(shape=..., name="input")</br>l = batch_norm(layers.Conv2DLayer(l,...))</br>l = layers.DenseLayer(l, num_units=30,...)
</br>net = NeuralNet(</br>  layers=l,</br>  max_epochs=1000,</br>)</pre></br>

<u>Approach 3</u></br>
And then I decided that the way the previous networks are defined - by using the NeurnalNet class from nolearn - is restricting (at least for me) because what if I wanted to have a custom loss function? Inspired by the <a href="https://github.com/Lasagne/Recipes/blob/master/papers/deep_residual_learning/Deep_Residual_Learning_CIFAR-10.py">Deep Residual Learning on CIFAR-10</a> code I dumped nolearn and started coding everything manually using theano functions and lasagne tools. The NeuralNetwork class is replaced by the following:</br></br>

<pre><i># Defining the layers first</i></br>l = layers.InputLayer(shape=..., name="input")</br>l = batch_norm(layers.Conv2DLayer(l,...))</br>l = layers.DenseLayer(l, num_units=30,...)

<i># Feedforward and compute the loss</i>
input_var = T.tensor4('inputs')</br>target_var = T.ivector('targets')</br>prediction = lasagne.layers.get_output(l)</br>loss = lasagne.objectives.categorical_crossentropy(prediction, target_var)</br>loss = loss.mean()

<i># Get the parameters (weights, biases etc.) and update them</i>
params = lasagne.layers.get_all_params(l, trainable=True)</br>updates = lasagne.updates.momentum(loss, params, learning_rate=sh_lr, momentum=sh_mom)

<i># Theano functions for the training loss and computation of test loss</i>
train_fn = theano.function([input_var, target_var], loss, updates=updates)<br>test_prediction = lasagne.layers.get_output(network, deterministic=True)<br>test_loss = lasagne.objectives.categorical_crossentropy(test_prediction, target_var)<br>test_loss = test_loss.mean()</pre></br>

This is more complicated than the previous two, more lines of code and less appealing but the upside is that we're capable of changing everything to our needs which at the end of the day is what makes Theano and Lasagne exciting.
<a name="conclusion"></a>
<h3>Conclusion</h3>
The way I see it, Deep Learning using ConvNets is just another Machine Learning tool that's essential to know and have it in your knowledge toolbox as it can help you address challenging tasks with great success that other ML methods cannot. In the recent years, there has been a great amount of publications suggesting methods that overcome existing problems (overfitting, number of parameters, initialization, internal covariate shift) while achieving at the same time classification results that have closed the gap to <a href="http://karpathy.github.io/2014/09/02/what-i-learned-from-competing-against-a-convnet-on-imagenet/">human-level performance</a> if something as abstract as that can be properly defined. Whether we're in a Deep Renaissance or in a <a href="https://www.linkedin.com/pulse/computer-vision-research-my-deep-depression-nikos-paragios">Deep Depression</a> period remains to be seen. In any case, experimenting with ConvNets is rewarding because there's always another idea to try, another nice publication to read, or <a href="https://blogs.nvidia.com/blog/category/deep-learning/">another meaningful application</a> that's using it. In the next few years Deep Learning might be everywhere around us, from medical imaging to reducing energy consumption, so if you like it, just keep digging. 




<a name="references"></a>
<h3>References</h3>    
    [1] K. He, X. Zhang, S. Ren, J. Sun, "Delving deep into rectifiers: Surpassing human-level performance on imagenet classification" in Proc. IEEE International Conference on Computer Vision, 2015, pp. 1026‚Äì1034.</br>
    [2] A. Krizhevsky, I. Sutskever, G. E. Hinton, "Imagenet classification with deep convolutional neural networks", in Advances in Neural Information Processing Systems, 2012, pp. 1097‚Äì1105.</br>
    [3] S. Ioffe, C. Szegedy, "Batch normalization: Accelerating deep network training by reducing internal covariate shift", arXiv preprint arXiv:1502.03167.</br>
    [4] Arpit, D., Zhou, Y., Kota, B.U. and Govindaraju, V.,  "Normalization Propagation: A Parametric Technique for Removing Internal Covariate Shift in Deep Networks." arXiv preprint arXiv:1603.01431, 2016.</br>
    [5] K. Simonyan, A. Zisserman, "Very Deep Convolutional Networks for Large-Scale Image Recognition."  arXiv preprint arXiv:1409.1556 (2014).</br>
    [6]  S. S. Kruthiventi, K. Ayush, R. V. Babu, Deepfix: A fully convolutional neural network for predicting human eye fixations. arXiv preprint arXiv:1510.02927, 2015 </br>
    [7] N. Srivastava, G. E. Hinton, A. Krizhevsky, I. Sutskever, R. Salakhutdinov,  "Dropout: a simple way to prevent neural networks from overfitting" Journal of Machine Learning Research, 15(1), 2014 1929-1958.</br>
    [8] I. J. Goodfellow, D. Warde-Farley, M. Mirza, A. C. Courville, Y. Bengio, "Maxout networks". ICML (3), 28, 2013,, 1319-1327.

</div>
</div>
</div>
<footer class="site-footer">
</footer>
</body>
</html>
